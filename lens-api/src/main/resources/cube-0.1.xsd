<?xml version="1.0" encoding="UTF-8" ?>
<!--

  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements. See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership. The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied. See the License for the
  specific language governing permissions and limitations
  under the License.

-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
  attributeFormDefault="unqualified" elementFormDefault="qualified"
  targetNamespace="uri:lens:cube:0.1" xmlns="uri:lens:cube:0.1" xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
  jaxb:version="2.1">

  <xs:annotation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="org.apache.lens.api.metastore"/>
      </jaxb:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <xs:element name="x_field" abstract="true" type="x_field"/>

  <xs:complexType name="x_field" abstract="true">
    <xs:annotation>
      <xs:documentation>
        some documentation
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="tags" type="x_properties" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Tags can be key value pairs associated with a field so that similar
            fields can be categorized into certain group.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute type="xs:string" name="name" use="required"/>
    <xs:attribute type="xs:string" name="display_string">
      <xs:annotation>
        <xs:documentation>
          Display string that should be shown to end users. Can be space separated. It gives UI systems
          built on top to use this value to show the field to end user.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute type="xs:string" name="description"/>
  </xs:complexType>

  <xs:element name="x_fields" type="x_fields"/>

  <xs:complexType name="x_fields">
    <xs:annotation>
      <xs:documentation>
        Set of fields.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_field" name="fields" maxOccurs="unbounded" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:element name="x_cube" type="x_cube"/>

  <xs:complexType name="x_cube" abstract="true">
    <xs:annotation>
      <xs:documentation>
        XCube can either be a Base cube for which the user would give the full specification of the
        measures and dimensions
        or can be a Derived cube, for which the user would specify only the measure names,
        dimension names and parent.
        Derived cube can have subset of measure names and dimension names associated with its
        parent. It can have
        different properties associated with it than the parent.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_properties" name="properties" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            The properties for the cube. The properties that should to be set are

            1. cube.{cube_name}.timed.dimensions.list - takes comma separated attribute names which are timed
            dimensions. This base cube's property gets propagated to its derived cubes.

            2. cube.timedim.partition.{time-dim-name} - This property needs to be set if the time dim attribute has its
            corresponding partition column different in the underlying storage tables. This base cube's property gets
            propagated to its derived cubes.

            The properties that are over-ridable are

            1. cube.allfields.queriable - (defaults to true) - If set to true, all the fields (measures, attributes) are
            queryable together. If set to false, there should be derived cubes defined that should group the queriable
            fields together.

            Additional properties:

            1. cube.timedim.relation.{time_dim1}: time_dim2+[timediff1,timediff2]. It's assumed that
            timediff1 is smaller than timediff2. Means that time_dim1 can be expected to be between
            [time_dim2+timediff1 and time_dim2+timediff2]. One use case would be the following:

            1.1. if a query is on range of time_dim1 and
            time_dim1 has no partitioning column in some fact, then partitions for time_dim2 can be looked at.
            Let's say time_dim2's part col is part_col2, then for a query asking for time_dim1 between [a,b) can
            be answered by looking at partitions of part_col2 in range [a-timediff2, b-timediff1).

            This property is first looked into fact properties, then cube properties and if that's a derived cube,
            then next in base cube properties. Wherever found first, that will be considered as the final relation
            between time dimensions.

            Time dimension relations are transitive, but not reversible. i.e.
            cube.timedim.relation.time_dim1 = time_dim2 + [a, b]
            cube.timedim.relation.time_dim2 = time_dim3 + [c, d]

            implies:

            cube.timedim.relation.time_dim1 = time_dim3 + [a+c, b+d]

            but not:

            cube.timedim.relation.time_dim2 = time_dim1 + [-b, -a]

            Reverse relations have to be defined explicitly.

            Timediff syntax is sign, quantity and unit. Spaces in between can be present. e.g. -4 days, +4days, +4 day
            etc all are valid.

          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute type="xs:string" name="name" use="required"/>
    <xs:attribute type="xs:string" name="description"/>
  </xs:complexType>

  <xs:element name="x_base_cube" type="x_base_cube"/>
  <xs:complexType name="x_base_cube">
    <xs:annotation>
      <xs:documentation>
        For XBaseCube, user would give the full specification of the measures and dimensions, expressions and
        join-chains.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="x_cube">
        <xs:sequence>
          <xs:element type="x_measures" name="measures" maxOccurs="1" minOccurs="1"/>
          <xs:element type="x_dim_attributes" name="dim_attributes" maxOccurs="1" minOccurs="0"/>
          <xs:element type="x_expressions" name="expressions" maxOccurs="1" minOccurs="0"/>
          <xs:element type="x_join_chains" name="join_chains" maxOccurs="1" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="x_derived_cube" type="x_derived_cube"/>
  <xs:complexType name="x_derived_cube">
    <xs:annotation>
      <xs:documentation>
        For XDerivedCube, user would specify only the measure names, dimension names and its parent.
        Derived cube can have a subset of measure names and dimension names of its parent. It can have different
        properties associated with it than its parent.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="x_cube">
        <xs:sequence>
          <xs:element type="x_measure_names" name="measure_names" maxOccurs="1" minOccurs="0"/>
          <xs:element type="x_dim_attr_names" name="dim_attr_names" maxOccurs="1" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="parent" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="x_dimension" type="x_dimension">
  </xs:element>
  <xs:complexType name="x_dimension">
    <xs:annotation>
      <xs:documentation>
        XDimension consists of set of attributes, expressions, join-chains
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_dim_attributes" name="attributes" maxOccurs="1" minOccurs="0"/>
      <xs:element type="x_expressions" name="expressions" maxOccurs="1" minOccurs="0"/>
      <xs:element type="x_join_chains" name="join_chains" maxOccurs="1" minOccurs="0"/>
      <xs:element type="x_properties" name="properties" maxOccurs="1" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute type="xs:string" name="name" use="required"/>
    <xs:attribute type="xs:string" name="description"/>
  </xs:complexType>

  <xs:complexType name="x_property">
    <xs:annotation>
      <xs:documentation>
        A key-value pair for storing property's name and its value.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute type="xs:string" name="name" use="required"/>
    <xs:attribute type="xs:string" name="value" use="required"/>
  </xs:complexType>

  <xs:complexType name="x_properties">
    <xs:annotation>
      <xs:documentation>
        A list of property elements.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_property" name="property" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_measure">
    <xs:annotation>
      <xs:documentation>
        A cube measure.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="x_field">
        <xs:attribute type="x_measure_type" name="_type" use="required"/>
        <xs:attribute type="xs:string" name="default_aggr">
          <xs:annotation>
            <xs:documentation>
              The aggregate for the measure that is used to rollup in aggregated facts.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="format_string">
          <xs:annotation>
            <xs:documentation>
              The string format that can should be used to format the number shown to user. For example:
              formatting with respect to precision upto 3 decimals, can be specified as
              format_number(%s,"##################.###")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:dateTime" name="start_time">
          <xs:annotation>
            <xs:documentation>
              The start time from when the measure is available for querying
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:dateTime" name="end_time">
          <xs:annotation>
            <xs:documentation>
              The end time till when the measure is available for querying
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="unit">
          <xs:annotation>
            <xs:documentation>
              Specify the unit of the measure. For example, currency in dollars or rupees.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:double" name="min">
          <xs:annotation>
            <xs:documentation>
              The minimum value the measure can take. This is only indicative value for user to know what
              vaues it can take. Lens does not do any validation based on this value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:double" name="max">
          <xs:annotation>
            <xs:documentation>
              The maximum value the measure can take. This is only indicative value for user to know what
              vaues it can take. Lens does not do any validation based on this value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="x_measures" type="x_measures"/>

  <xs:complexType name="x_measures">
    <xs:annotation>
      <xs:documentation>
        Set of measures.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_measure" name="measure" maxOccurs="unbounded" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_measure_names">
    <xs:annotation>
      <xs:documentation>
        Set of measure names.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="xs:string" name="measure_name" maxOccurs="unbounded" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_expr_column">
    <xs:annotation>
      <xs:documentation>
        An expression column
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="x_field">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation>
              All the expressions associated with expression column.
            </xs:documentation>
          </xs:annotation>
          <xs:element type="x_expr_spec" name="expr_spec" maxOccurs="unbounded" minOccurs="1"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="_type" use="required">
          <xs:annotation>
            <xs:documentation>
              The type indicating what the evaluation of expression will produce. Allowed types are BOOLEAN, TINYINT,
              SMALLINT, INT, BIGINT, FLOAT, DOUBLE, DECIMAL, STRING, CHAR, VARCHAR, DATE, TIMESTAMP, BINARY, ARRAY, MAP,
              STRUCT, UNION
              See hive represenation for specifying complex types -
              https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types#LanguageManualTypes-ComplexTypes
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="x_expr_spec">
    <xs:annotation>
      <xs:documentation>
        Specification of single expression. Specification consists of required expression field, and optional start and
        end times associated with expression. Expression is valid between start time and end time, if both are
        specified. If only start_time is specified, is valid from start_time to till date. If only end_time is
        specified, is valid upto date specified, from any time. If no start time, end time are specified, the
        expression is always valid.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute type="xs:string" name="expr" use="required">
      <xs:annotation>
        <xs:documentation>
          The expression can be any string parsable through Hive Query Language.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute type="xs:dateTime" name="start_time">
      <xs:annotation>
        <xs:documentation>
          The start time from when the expression is valid.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute type="xs:dateTime" name="end_time">
      <xs:annotation>
        <xs:documentation>
          The end time till when the expression is valid.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:element name="x_expressions" type="x_expressions"/>

  <xs:complexType name="x_expressions">
    <xs:annotation>
      <xs:documentation>
        Set of expressions.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_expr_column" name="expression" maxOccurs="unbounded" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_dim_attribute">
    <xs:annotation>
      <xs:documentation>
        A dim attribute.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="x_field">
        <xs:sequence>
          <xs:element type="x_chain_column" name="chain_ref_column" maxOccurs="unbounded" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Chain column specification needs to be specified if the attribute is a reference attribute.
                It can be list of chained columns each specified with chain name and column name.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="hierarchy" type="x_dim_attributes" maxOccurs="1" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                If the dim attribute is a hierarchical attribute consisting of more dim attribute. This specification
                is supplied in the definition. When cube or dimension has a hierarchy defined, the underlying fact or
                dimtables, can have one or more elements in the hierarchy.
                For example, location can be hierarchical dim attribute with its hierarchy defined as zipcode, city,
                state and country; A fact can have zipcode and city as columns in the table and another fact can have
                city alone.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="values" type="xs:string" maxOccurs="unbounded" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                These values specified here represent what actual values the dim attribute can take. This value is
                usually specified if the values the attribute can take are minimal and can be listed. This is more
                indicative information specified, for user to understand what values the attribute can hold.
                For example, a gender attribute can enumerate the values attribute can take and specify them here.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute type="xs:string" name="_type">
          <xs:annotation>
            <xs:documentation>
              The type indicating what the evaluation of expression will produce. Allowed types are BOOLEAN,TINYINT,
              SMALLINT, INT, BIGINT, FLOAT, DOUBLE, DECIMAL, STRING, CHAR, VARCHAR, DATE, TIMESTAMP, BINARY, ARRAY, MAP,
              STRUCT, UNION
              See hive represenation for specifying complex types -
              https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types#LanguageManualTypes-ComplexTypes
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:dateTime" name="start_time">
          <xs:annotation>
            <xs:documentation>
              The start time from when the attribute is available for querying.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:dateTime" name="end_time">
          <xs:annotation>
            <xs:documentation>
              The end time till when the attribute is available for querying.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:long" name="num_distinct_values" use="optional">
          <xs:annotation>
            <xs:documentation>
              Specifies an indicative value of how many distinct values the dim attribute can take.
              This would give an idea of how big the grouping will be when an attribute is chosen for groupby
              expressions.
              This is just an approximate value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="x_dim_attributes" type="x_dim_attributes"/>

  <xs:complexType name="x_dim_attributes">
    <xs:annotation>
      <xs:documentation>
        Set of dim attributes.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_dim_attribute" name="dim_attribute" maxOccurs="unbounded" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_dim_attr_names">
    <xs:annotation>
      <xs:documentation>
        Set of dim attribute names.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="xs:string" name="attr_name" maxOccurs="unbounded" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_chain_column">
    <xs:attribute type="xs:string" name="chain_name" use="required"/>
    <xs:attribute type="xs:string" name="ref_col" use="required"/>
    <xs:attribute type="xs:string" name="dest_table">
      <xs:annotation>
        <xs:documentation>
          This will be the destination table of the chain. LENS will set and return, need not be set by end-user.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="x_table_reference">
    <xs:attribute type="xs:string" name="table" use="required"/>
    <xs:attribute type="xs:string" name="column" use="required"/>
    <xs:attribute type="xs:boolean" name="maps_to_many" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>
          This boolean is used to specify if the destination reference can map to many rows for single value of source
          reference. Mainly signifies if there are bridge tables.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:element name="x_join_chains" type="x_join_chains"/>

  <xs:complexType name="x_join_chains">
    <xs:annotation>
      <xs:documentation>
        Set of join chains.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_join_chain" name="join_chain" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_join_chain">
    <xs:annotation>
      <xs:documentation>
        Join chain represents the paths to reach a dimension.
        For example, to reach Country from
        SalesCube, there can be the following equivalent paths:
        SalesCube.deliveryStateid -&amp;gt; State.id, State.countryid -&amp;gt; Country.id
        SalesCube.deliveryCityid -&amp;gt; City.id, City.stateid -&amp;gt; State.id, State.countryid -&amp;gt;Country.id
        Both the above paths will be associated with same
        join chain i.e with same name, if they are equivalent and at
        runtime, LENS will choose the path to use. If the
        paths are not equivalent, they should be named differently.
        SalesCube.productionStateid -&amp;gt; State.id,
        State.countryid -&amp;gt;Country.id will be named differently.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="x_field">
        <xs:sequence>
          <xs:element type="x_join_paths" name="paths" maxOccurs="1" minOccurs="1"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="dest_table">
          <xs:annotation>
            <xs:documentation>
              This will be the destination table of the chain. LENS will set and return, need not be set by end-user.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="x_join_path">
    <xs:annotation>
      <xs:documentation>
        Represents a path associated with chain.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_join_edges" name="edges" maxOccurs="1" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_join_paths">
    <xs:annotation>
      <xs:documentation>
        Set of join paths.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_join_path" name="path" maxOccurs="unbounded" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_join_edge">
    <xs:annotation>
      <xs:documentation>
        Represents an edge associated with join path.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_table_reference" name="from" maxOccurs="1" minOccurs="1"/>
      <xs:element type="x_table_reference" name="to" maxOccurs="1" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_join_edges">
    <xs:annotation>
      <xs:documentation>
        Sequence of join edges.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_join_edge" name="edge" maxOccurs="unbounded" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:element name="x_dimension_table" type="x_dimension_table">
  </xs:element>

  <xs:complexType name="x_dimension_table">
    <xs:annotation>
      <xs:documentation>
        DimensionTable which belongs to a Dimension. The columns in the dimension table will be a subset
        of all fields in Dimension.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="columns" type="x_columns" maxOccurs="1" minOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Columns in the table. The order of columns here should be same as the order of columns in
            the underlying physical tables.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element type="x_properties" name="properties" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Dimension table properties. The properties that should be set are:
            1. dimtable.{dim_table_name}.part.cols = comma separated list of partition columns of this dimtable.
            This would basically be union of all partition columns of all storage tables of the dimtable.
            Setting this makes that partition column queryable.
            Time part columns can be skipped as they will generally not be queried.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element type="x_storage_tables" name="storage_tables" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Storage tables associated with the dimension table, specifying storage name, table description and
            dump period, if any
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="dimension_name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The dimension to which the dimension_table belongs to.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="table_name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The dimension table name
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="weight" use="required" >
      <xs:annotation>
        <xs:documentation>
          The weight of the dimension table. LENS will use this attribute to determine the lightest
          table when there are more than one eligible table for answering a query.
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:double">
          <xs:minInclusive value="0"></xs:minInclusive>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="x_update_periods">
    <xs:sequence>
      <xs:element name="update_period" type="x_update_period" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_columns">
    <xs:sequence>
      <xs:element name="column" type="x_column" maxOccurs="unbounded" minOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_column">
    <xs:annotation>
      <xs:documentation>
        Column in table.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required"/>
    <xs:attribute type="xs:string" name="_type" use="required">
      <xs:annotation>
        <xs:documentation>
          The type indicating what the evaluation of expression will produce. Allowed types are BOOLEAN, TINYINT,
          SMALLINT, INT, BIGINT, FLOAT, DOUBLE, DECIMAL, STRING, CHAR, VARCHAR, DATE, TIMESTAMP, BINARY, ARRAY, MAP,
          STRUCT, UNION
          See hive represenation for specifying complex types -
          https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types#LanguageManualTypes-ComplexTypes
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="xs:string"/>
    <xs:attribute name="start_time" type="xs:string"/>
    <xs:attribute name="end_time" type="xs:string"/>
  </xs:complexType>

  <xs:simpleType name="x_measure_type">
    <xs:annotation>
      <xs:documentation>
        Measure Types allowed.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="TINYINT"/>
      <xs:enumeration value="SMALLINT"/>
      <xs:enumeration value="INT"/>
      <xs:enumeration value="BIGINT"/>
      <xs:enumeration value="FLOAT"/>
      <xs:enumeration value="DOUBLE"/>
      <xs:enumeration value="DECIMAL"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="x_update_period">
    <xs:annotation>
      <xs:documentation>
        Update periods allowed.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="CONTINUOUS"/>
      <xs:enumeration value="SECONDLY"/>
      <xs:enumeration value="MINUTELY"/>
      <xs:enumeration value="HOURLY"/>
      <xs:enumeration value="DAILY"/>
      <xs:enumeration value="WEEKLY"/>
      <xs:enumeration value="MONTHLY"/>
      <xs:enumeration value="QUARTERLY"/>
      <xs:enumeration value="YEARLY"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:element name="x_storage" type="x_storage"/>
  <xs:complexType name="x_storage">
    <xs:annotation>
      <xs:documentation>
        The storage specified by name, which would represent the underlying storage of data.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_properties" name="properties" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Storage properties
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required"/>
    <xs:attribute name="classname" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The implementation class of the storage. LENS provides the following in-built implementations:
          org.apache.lens.cube.metadata.HDFSStorage
          and org.apache.lens.storage.db.DBStorage.
          Custom implementation can be specified as long as they are available at server's runtime.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:element name="x_storage_table_desc" type="x_storage_table_desc"/>
  <xs:complexType name="x_storage_table_desc">
    <xs:annotation>
      <xs:documentation>
        The storage table description specifies the underlying format wrt how to read/write data.
        See
        https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-Create/Drop/TruncateTable
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="part_cols" type="x_columns" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            The partition columns for the table, if partitioned.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element type="x_properties" name="table_parameters" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Table properties.
            The following properties can be specified for DBStorage table :
            1. lens.metastore.native.db.name : The underlying databse name in DB storage.
            2. lens.metastore.native.table.name : The underlying table name in DB storage.
            3. lens.metastore.native.table.column.mapping : The column mapping for columns of the table if they are
            different in underlying DB storage. The value is specified with comma separated map entries specified with
            key-values separated by equalto. Example value: id=id1,name=name1
            The following properties can be specified for Elastic search tables :
            1. lens.metastore.es.index.name : The underlying ES index name.
            2. lens.metastore.es.type.name : The underlying ES type name.
            Start and End times for storage table:
            1. cube.storagetable.start.times: Comma separated list of start times for this table.
               Start times can be relative times(e.g. now.day - 1 month) or absolute times(e.g. 2014-02)
               The max of the start times will be considered as the final start time. This storagetable will
               not be candidate for answering time ranges completely before its start time.
            2. cube.storagetable.end.times: Comma separated list of end times for this table.
               End times can be relative times(e.g. now.day - 1 month) or absolute times(e.g. 2014-02)
               The min of the end times will be considered as the final end time. This storagetable will not be
               candidate for answering time ranges completely after its end time.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element type="x_properties" name="serde_parameters" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Serde properties.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="bucket_cols" type="xs:string" maxOccurs="unbounded" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            List of bucket columns if the table is bucketed.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sort_cols" type="xs:string" maxOccurs="unbounded" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            List of sort columns if the table is bucketed.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sort_col_order" type="xs:int" maxOccurs="unbounded" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            List of sort column order if the table is bucketed.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="skewed_info" type="x_skewed_info" maxOccurs="unbounded" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Skewed info, if the table is skewed. Expressed as
            SKEWED BY (col_name, col_name, ...) ON ([(col_value, col_value, ...), ...|col_value, col_value, ...].
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="time_part_cols" type="xs:string" maxOccurs="unbounded" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            List of partition columns which are time partition columns. Will be a subset of partition columns.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="external" type="xs:boolean" use="required">
      <xs:annotation>
        <xs:documentation>
          Tells whether the table is external table or managed table.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="table_location" type="xs:anyURI">
      <xs:annotation>
        <xs:documentation>
          Table location. The location of the external table, if not partitioned. Would be dummy for
          external tables which are partitioned, because data is only available when partitions are registered.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="input_format" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The input format for reading the underlying data.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="output_format" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The output format for writing the underlying data, will not be used while querying.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="field_delimiter" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Field delimiter if the row format is TEXTFILE.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="escape_char" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Escape character if the row format is TEXTFILE.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collection_delimiter" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Collection delimiter if the row format is TEXTFILE.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="line_delimiter" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Line delimiter if the row format is TEXTFILE.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="map_key_delimiter" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Map key delimiter if the row format is TEXTFILE.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serde_class_name" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The serde class name, if not default.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storage_handler_name" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The storage handler class name, if stored by storage handler.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="num_buckets" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          Number of buckets in the table, if bucketed.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compressed" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Tells whether the data is compressed or not.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="x_skewed_info">
    <xs:annotation>
      <xs:documentation>
        Table skew info.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="col_names" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
      <xs:element name="col_values" type="x_skew_col_list" maxOccurs="unbounded" minOccurs="0"/>
      <xs:element name="value_location_map" type="x_skewed_value_location" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_skew_col_list">
    <xs:annotation>
      <xs:documentation>
        Skew column list.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="elements" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_skewed_value_location">
    <xs:annotation>
      <xs:documentation>
        Map of the list of values to location.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="value" type="x_skew_col_list" minOccurs="1" maxOccurs="1"/>
    </xs:sequence>
    <xs:attribute type="xs:string" name="location" use="required"/>
  </xs:complexType>

  <xs:element name="x_storage_table_element" type="x_storage_table_element"/>

  <xs:complexType name="x_storage_table_element">
    <xs:annotation>
      <xs:documentation>
        Storage and storage table description and update periods
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="update_periods" type="x_update_periods" maxOccurs="1" minOccurs="0"/>
      <xs:element name="storage_name" type="xs:string"/>
      <xs:element type="x_storage_table_desc" name="table_desc"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_storage_tables">
    <xs:annotation>
      <xs:documentation>
        Storage table elements describing the storage name, its update periods and table description.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="storage_table" minOccurs="0" maxOccurs="unbounded" type="x_storage_table_element"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_segment">
    <xs:annotation>
      <xs:documentation>
        Segment belong to the segmentation
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="segment_parameters" type="x_properties" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Segment properties.
            The following properties can be specified at a segment level :
            1. lens.metastore.cube.column.mapping : The column mapping for columns of segment if they are
            different in underlying cube. The value is speciified with comma separated map entries specified with
            key-values separated by equalto. Example value: id=id1,name=name1
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="cube_name"  type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="x_segments">
    <xs:annotation>
      <xs:documentation>
        Segments in segmentation. There can be two or more such segments.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="segment" minOccurs="2" maxOccurs="unbounded" type="x_segment"/>
    </xs:sequence>
  </xs:complexType>

  <xs:element name="x_partition_list" type="x_partition_list"/>
  <xs:complexType name="x_partition_list">
    <xs:annotation>
      <xs:documentation>
        Compact data structure for storing List of partitions.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="partition" type="x_partition" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:element name="x_partition" type="x_partition"/>

  <xs:complexType name="x_partition">
    <xs:annotation>
      <xs:documentation>
        Partition details
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="non_time_partition_spec" maxOccurs="1" minOccurs="0" type="x_part_spec">
        <xs:annotation>
          <xs:documentation>
            Non time partition specification with partition columns and values.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="time_partition_spec" maxOccurs="1" minOccurs="0" type="x_time_part_spec">
        <xs:annotation>
          <xs:documentation>
            Time partition specification with partition columns and date values.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="full_partition_spec" maxOccurs="1" minOccurs="0" type="x_part_spec">
        <xs:annotation>
          <xs:documentation>
            LENS would use this type to retun the specification elements. Should not be used directly by end-user.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element type="x_properties" name="partition_parameters" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Partition properties.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element type="x_properties" name="serde_parameters" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Serde properties.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute type="xs:string" name="fact_or_dimension_table_name" use="required">
      <xs:annotation>
        <xs:documentation>
          The table name (fact table/dimension table) to which the partition belongs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute type="xs:string" name="name">
      <xs:annotation>
        <xs:documentation>
          Name of the partition will be set to the fully qualified specification and returned when
          XPartition is returned. Need not be passed when creating a partition.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute type="xs:string" name="location">
      <xs:annotation>
        <xs:documentation>
          Location of the partition.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute type="xs:string" name="input_format">
      <xs:annotation>
        <xs:documentation>
          Should be passed if different from the table definition.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute type="xs:string" name="output_format">
      <xs:annotation>
        <xs:documentation>
          Should be passed if different from the table definition.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute type="xs:string" name="serde_classname">
      <xs:annotation>
        <xs:documentation>
          Should be passed if different from the table definition.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="update_period" type="x_update_period">
      <xs:annotation>
        <xs:documentation>
          Update period if the partition has timed partition specification. All time partition columns will be on same
          update period.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="x_part_spec_element">
    <xs:annotation>
      <xs:documentation>
        Partition column name and its value.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute type="xs:string" name="key" use="required"/>
    <xs:attribute type="xs:string" name="value" use="required"/>
  </xs:complexType>

  <xs:complexType name="x_part_spec">
    <xs:sequence>
      <xs:element type="x_part_spec_element" name="part_spec_element" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="x_time_part_spec_element">
    <xs:annotation>
      <xs:documentation>
        Time partition column name and its value as date-time.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute type="xs:string" name="key" use="required"/>
    <xs:attribute type="xs:dateTime" name="value" use="required"/>
  </xs:complexType>

  <xs:complexType name="x_time_part_spec">
    <xs:sequence>
      <xs:element type="x_time_part_spec_element" name="part_spec_element" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:element name="x_fact_table" type="x_fact_table"/>

  <xs:complexType name="x_fact_table">
    <xs:annotation>
      <xs:documentation>
        Fact table that is associated to a base cube. The columns in the fact table will be a subset of
        all fields in the base cube.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="columns" type="x_columns" maxOccurs="1" minOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Columns in the table. Columns should be in the same order as in the underlying physical tables.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element type="x_properties" name="properties" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Properties that can be set for a fact are

            1. cube.fact.{fact-name}.valid.columns.size : This should be set to number of
            cube.fact.{fact-name}.valid.columns strings.
            2. cube.fact.{fact-name}.valid.columns{i} : This should be set to comma separated column names which are
            valid in the fact, such that 0 &lt;= i &lt; cube.fact.{fact-name}.valid.columns.size and each of
            cube.fact.{fact-name}.valid.columns{i} has maximum length of 3999.
            3. cube.fact.is.aggregated : Defaults to true. If the fact is a raw fact, this should be set to false,
            otherwise true.
            4. cube.timedim.relation.{time_dim1}: See the same property in cube. Fact tables can override the property.
            5. cube.fact.absolute.start.time: start time of the fact. For queries that ask for time before this,
            this fact is not a candidate. Time format can be as you would specify in the time_range_in clause.
            i.e. yyyy[-mm[-dd[-hh[:MM[:ss[,SSS]]]]]]
            6. cube.fact.relative.start.time: Here you can specify fact's relative validity relative to current time.
            Useful if you want to specify e.g. this fact is valid for today - 90 days. Can be specified as just
            a time difference e.g. "-90 days". Or can be specified in relative syntax.
            e.g. now.year or now.day - 6 hour etc.
            7. cube.fact.absolute.end.time: If you're deprecating this fact, put the final date till which the data of
            the fact will be valid here. Format same as absolute start time.
            8. cube.fact.relative.end.time: You can specify the end date for fact table
            relative to current date e.g. fact table is valid for next 90days starting from today.
            This can be specified as just a time difference e.g. "+90 days"
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="storage_tables" type="x_storage_tables" maxOccurs="1" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The fact table name.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cube_name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The base cube's name to which the fact_table is associated.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="weight" use="required" >
      <xs:annotation>
        <xs:documentation>
          The weight of the fact table. LENS will use this attribute to decide the lightest table to
          query when there are more than one eligible tables.
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:double">
          <xs:minInclusive value="0"></xs:minInclusive>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:element name="x_segmentation" type="x_segmentation"/>

  <xs:complexType name="x_segmentation">
    <xs:annotation>
      <xs:documentation>
        Segmentation is associated to a base cube and consists of two or more segments. All
        segments together make segmentation complete.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element type="x_properties" name="properties" maxOccurs="1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Properties that can be set for segmentation are
            1. cube.segmentation.absolute.start.time: start time of the segmentation.
            For queries that ask for time before this, this segmentation is not a candidate. Time format
            can be specified in yyyy[-mm[-dd[-hh[:MM[:ss[,SSS]]]]]] format.
            2. cube.segmentation.relative.start.time: Here you can specify segmentations's relative validity
            relative to current time. Useful if you want to specify e.g. this segmentation is valid
            for today - 90 days. Can be specified as just a time difference e.g. "-90 days".
            Or can be specified in relative syntax.
            e.g. now.year or now.day - 6 hour etc.
            3. cube.segmentation.absolute.end.time: If you're deprecating a segmentation, put the final date till
            which the data of the segmentation will be valid here. Format same as absolute start time.
            4. cube.segmentation.relative.end.time: You can specify the end date for segmentation
            relative to current date e.g. segmentationas is valid for next 90 days starting from today.
            This can be specified as just a time difference e.g. "+90 days".
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="segements" type="x_segments" maxOccurs="1" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Name of Segmentation
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cube_name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The base or parent cube to which the segmentation is associated.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="weight" use="required" >
      <xs:annotation>
        <xs:documentation>
          The weight of the segmentation. LENS will use this attribute to decide the lightest table to
          query when there are more than one eligible tables.
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:double">
          <xs:minInclusive value="0"></xs:minInclusive>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:element name="x_native_table" type="x_native_table"/>
  <xs:complexType name="x_native_table">
    <xs:annotation>
      <xs:documentation>
        Native tables in metastore. Would never be created by client. This specification is used by the
        LENS API to.
        return this information to the end user.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="columns" type="x_columns" maxOccurs="1" minOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Columns of the native table.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element type="x_storage_table_desc" name="storage_descriptor">
        <xs:annotation>
          <xs:documentation>
            Table description in metastore.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Name of the native table.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dbname" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          DB in which the table is present.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="owner" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation>
          Owner of the table.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="table_type" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Type of the table whether EXTERNAL or MANAGED
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createtime" type="xs:int" use="required">
      <xs:annotation>
        <xs:documentation>
          Table creation time.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lastAccessTime" type="xs:int" use="required">
      <xs:annotation>
        <xs:documentation>
          Last access time of the table.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:element name="x_flattened_columns" type="x_flattened_columns"/>
  <xs:complexType name="x_flattened_columns">
    <xs:annotation>
      <xs:documentation>
        LENS will use this type to return all flattened columns reachable from a cube or dimension.
        This type is not expected to be created by end-users directly.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="flattened_column" type="x_flattened_column" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="x_flattened_column">
    <xs:choice maxOccurs="1" minOccurs="1">
      <xs:element name="measure" type="x_measure"/>
      <xs:element name="expression" type="x_expr_column"/>
      <xs:element name="dim_attribute" type="x_dim_attribute"/>
    </xs:choice>
    <xs:attribute name="table_name" type="xs:string" use="required"/>
    <xs:attribute name="chain_name" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          For chained columns, the destination table of the chain will be returned in table_name and the
          chain_name will be populated as well.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
</xs:schema>
